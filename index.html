<!DOCTYPE html>
<html>
<head>
    <title>WebRTC Collaborative Whiteboard</title>
    <style>
        body { font-family: sans-serif; display: flex; flex-direction: column; align-items: center; margin: 20px; background-color: #f4f4f9; }
        #app-container { background-color: white; padding: 20px; border-radius: 8px; box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2); }
        #whiteboard { border: 2px solid #333; cursor: crosshair; background-color: white; display: block; }
        .controls { margin-bottom: 15px; display: flex; flex-wrap: wrap; gap: 10px; align-items: center; }
        .controls input, .controls button { padding: 8px 12px; border-radius: 4px; border: 1px solid #ccc; cursor: pointer; transition: background-color 0.2s; }
        .controls button:hover { background-color: #e0e0e0; }
        .controls button.active { background-color: #5cb85c; color: white; border-color: #4cae4c; }
        .status-bar { margin-top: 10px; font-size: 0.9em; color: #555; }
        .color-picker { width: 30px; height: 30px; padding: 0; border: none; cursor: pointer; }
    </style>
</head>
<body>
    <div id="app-container">
        <h1>Collaborative Whiteboard</h1>

        <div class="controls">
            <input type="text" id="username" placeholder="Username" value="user_A">
            <button id="btnLogin">1. Login</button>
            <span id="authStatus">Not logged in.</span>
        </div>

        <div class="controls">
            <button id="btnCreate">2. Create Session</button>
            <input type="text" id="sessionIdInput" placeholder="Enter Session ID">
            <button id="btnJoin" disabled>3. Join Session</button>
        </div>

        <div class="controls">
            <button id="btnPen" class="active">Pen</button>
            <button id="btnEraser">Eraser</button>
            <input type="color" id="colorPicker" class="color-picker" value="#000000">
            <input type="range" id="sizeSlider" min="1" max="15" value="5">
            
            <button id="btnSave" disabled>4. Save Canvas</button>
            <button id="btnClear">Clear Local</button>
        </div>

        <canvas id="whiteboard" width="800" height="600"></canvas>
        <div class="status-bar">
            **Session:** <span id="sessionStatus">N/A</span> |
            **WebRTC Status:** <span id="webrtcStatus" style="color: red;">Disconnected</span> |
            **User:** <span id="currentUserName"></span>
        </div>
    </div>

    <script>
        // --- Global State ---
        const CANVAS_WIDTH = 800;
        const CANVAS_HEIGHT = 600;
        const canvas = document.getElementById('whiteboard');
        const ctx = canvas.getContext('2d');
        
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let drawingHistory = []; 
        let currentTool = 'pen'; // State for pen vs. eraser
        
        let peerConnection;
        let dataChannel;
        let ws; 
        
        // App State
        let currentToken = null;
        let currentSessionId = null;
        let currentUserName = '';

        // --- DEPLOYMENT CONFIGURATION ---
        // IMPORTANT: CHANGE 'localhost:8000' to your deployed server address (e.g., 'https://my-app.com')
        // index.html <script>
// The browser will automatically handle the 'https://' and 'wss://'
        const DEPLOYED_HOST = 'whiteboard-axcw.onrender.com'; 
// ... the rest of your code ... 
        const PROTOCOL = DEPLOYED_HOST.startsWith('localhost') ? 'http' : 'https';
        const WS_PROTOCOL = DEPLOYED_HOST.startsWith('localhost') ? 'ws' : 'wss';
        const API_BASE = `${PROTOCOL}://${DEPLOYED_HOST}/api`; 

        // --- UI Element References ---
        const authStatus = document.getElementById('authStatus');
        const sessionStatus = document.getElementById('sessionStatus');
        const webrtcStatus = document.getElementById('webrtcStatus');
        const currentUserNameEl = document.getElementById('currentUserName');
        const sessionIdInput = document.getElementById('sessionIdInput');
        
        // --- API & Auth Helpers ---
        function getAuthHeaders() {
            return {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${currentToken}`
            };
        }

        async function handleLogin() {
            const username = document.getElementById('username').value;
            if (!username) return alert("Please enter a username.");

            try {
                const response = await fetch(`${API_BASE}/login`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ username })
                });

                if (response.ok) {
                    const data = await response.json();
                    currentToken = data.access_token;
                    currentUserName = data.username;
                    authStatus.textContent = `Logged in as: ${currentUserName}`;
                    currentUserNameEl.textContent = currentUserName;
                    document.getElementById('btnJoin').disabled = false;
                    document.getElementById('btnCreate').disabled = false;
                } else {
                    alert("Login failed.");
                }
            } catch (error) {
                console.error('Login error:', error);
                alert("Login failed. Check server address/CORS or if the FastAPI server is running.");
            }
        }

        async function handleCreateSession() {
            if (!currentToken) return alert("Please log in first.");

            try {
                const response = await fetch(`${API_BASE}/sessions`, {
                    method: 'POST',
                    headers: getAuthHeaders()
                });

                if (response.ok) {
                    const session = await response.json();
                    currentSessionId = session.session_id;
                    sessionIdInput.value = currentSessionId;
                    handleJoinSession(true); // Auto-join and set as initiator
                } else {
                    alert("Failed to create session.");
                }
            } catch (error) {
                console.error('Create session error:', error);
            }
        }
        
        async function handleSaveCanvas() {
            if (!currentToken || !currentSessionId) {
                alert("Please join a session first.");
                return;
            }
            
            if (drawingHistory.length === 0) {
                alert("Nothing to save - canvas is empty.");
                return;
            }
            
            // Disable save button during save operation
            const saveBtn = document.getElementById('btnSave');
            saveBtn.disabled = true;
            sessionStatus.textContent = "Saving canvas...";
            
            try {
                console.log(`Saving ${drawingHistory.length} drawing commands to session ${currentSessionId}`);
                
                const response = await fetch(`${API_BASE}/sessions/${currentSessionId}/save`, {
                    method: 'POST',
                    headers: getAuthHeaders(),
                    body: JSON.stringify(drawingHistory) // Send the entire history array
                });

                if (response.status === 204) {
                    sessionStatus.textContent = `âœ“ Session ${currentSessionId} saved successfully!`;
                    console.log("Canvas saved successfully!");
                } else if (response.status === 404) {
                    const errorData = await response.json().catch(() => ({ detail: "Session not found" }));
                    alert(`Session not found: ${errorData.detail || "Please create or join a session first."}`);
                    sessionStatus.textContent = "Save failed: Session not found.";
                } else if (response.status === 401) {
                    alert("Authentication failed. Please log in again.");
                    sessionStatus.textContent = "Save failed: Authentication error.";
                } else if (response.status === 422) {
                    const errorData = await response.json().catch(() => ({ detail: "Validation error" }));
                    console.error("Validation error:", errorData);
                    alert(`Failed to save: ${errorData.detail || "Invalid data format."}`);
                    sessionStatus.textContent = "Save failed: Validation error.";
                } else {
                    const errorText = await response.text().catch(() => "Unknown error");
                    console.error("Save failed with status:", response.status, errorText);
                    alert(`Failed to save canvas state. Status: ${response.status}`);
                    sessionStatus.textContent = `Save failed (Status: ${response.status}).`;
                }
            } catch (error) {
                console.error('Save error:', error);
                alert(`Failed to save canvas: ${error.message || "Network error. Check console for details."}`);
                sessionStatus.textContent = "Save failed: Network error.";
            } finally {
                saveBtn.disabled = false;
            }
        }

        function clearCanvas() {
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            drawingHistory = []; // Clear local history
            sessionStatus.textContent = `Canvas cleared locally. (Must save to persist!)`;
        }

        // --- Canvas Drawing Logic ---
        function drawLine(x1, y1, x2, y2, color, size, tool) {
            ctx.beginPath();
            
            // Set globalCompositeOperation for eraser effect
            ctx.globalCompositeOperation = (tool === 'eraser') ? 'destination-out' : 'source-over'; 

            ctx.strokeStyle = color;
            ctx.lineWidth = size;
            ctx.lineCap = 'round';
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();

            // Reset composite operation to default
            ctx.globalCompositeOperation = 'source-over';
        }

        function handleRemoteDrawing(event) {
            try {
                const cmd = JSON.parse(event.data);
                if (cmd.x1 !== undefined) {
                    drawLine(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.color, cmd.size, cmd.tool);
                    drawingHistory.push(cmd); // Add remote command to history
                }
            } catch (e) {
                console.error("Failed to parse remote drawing data:", e);
            }
        }

        function setupCanvasDrawing() {
            canvas.addEventListener('mousedown', (e) => {
                // Only start drawing if a session is active
                if (!currentSessionId) return;
                isDrawing = true;
                [lastX, lastY] = [e.offsetX, e.offsetY];
            });

            canvas.addEventListener('mousemove', (e) => {
                if (!isDrawing || !currentSessionId) return;
                
                const color = document.getElementById('colorPicker').value;
                const size = parseInt(document.getElementById('sizeSlider').value);

                // For the eraser, use a white stroke color or the canvas background color
                const strokeColor = (currentTool === 'eraser') ? 'white' : color;
                
                // Draw locally
                drawLine(lastX, lastY, e.offsetX, e.offsetY, strokeColor, size, currentTool);
                
                const command = {
                    x1: lastX, y1: lastY, 
                    x2: e.offsetX, y2: e.offsetY, 
                    color: strokeColor, 
                    size: size,
                    tool: currentTool // Send the tool used!
                };

                // Add to history and send via WebRTC Data Channel
                drawingHistory.push(command); 
                if (dataChannel && dataChannel.readyState === 'open') {
                    dataChannel.send(JSON.stringify(command));
                }

                [lastX, lastY] = [e.offsetX, e.offsetY];
            });

            canvas.addEventListener('mouseup', () => isDrawing = false);
            canvas.addEventListener('mouseout', () => isDrawing = false);
        }

        function loadCanvasState(commands) {
            // Clear and reset state before loading
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            drawingHistory = []; 
            
            commands.forEach(cmd => {
                drawLine(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.color, cmd.size, cmd.tool);
                drawingHistory.push(cmd);
            });
            console.log(`Loaded ${commands.length} drawing commands.`);
        }

        // --- WebRTC Signaling and Peer Connection ---
        
        async function handleJoinSession(isInitiator = false) {
            currentSessionId = sessionIdInput.value.trim();
            if (!currentSessionId) return alert("Please enter a Session ID.");
            if (!currentToken) return alert("Please log in first.");

            sessionStatus.textContent = `Joining session: ${currentSessionId}...`;
            document.getElementById('btnSave').disabled = true;

            // 1. Load Initial Canvas State from API
            try {
                const response = await fetch(`${API_BASE}/sessions/${currentSessionId}`, { headers: getAuthHeaders() });
                if (!response.ok) throw new Error("Session load failed.");
                const sessionData = await response.json();
                loadCanvasState(sessionData.canvas_state); // Restore drawing
            } catch (error) {
                console.error("Error loading session:", error);
                sessionStatus.textContent = `Session ${currentSessionId} load failed. Check ID and server logs.`;
                return;
            }
            
            // 2. Setup WebSocket for Signaling
            ws = new WebSocket(`${WS_PROTOCOL}://${DEPLOYED_HOST}/ws/${currentSessionId}`);
            
            ws.onopen = () => {
                console.log("WebSocket connected. Starting WebRTC signaling...");
                setupPeerConnection(isInitiator);
            };
            
            // WebSocket Message Handler (Signaling Exchange)
            ws.onmessage = async (event) => {
                const signal = JSON.parse(event.data);

                if (signal.type === 'offer') {
                    await peerConnection.setRemoteDescription(new RTCSessionDescription(signal));
                    const answer = await peerConnection.createAnswer();
                    await peerConnection.setLocalDescription(answer);
                    ws.send(JSON.stringify(peerConnection.localDescription)); // Send Answer back
                } else if (signal.type === 'answer') {
                    await peerConnection.setRemoteDescription(new RTCSessionDescription(signal));
                } else if (signal.type === 'candidate') {
                    try {
                        await peerConnection.addIceCandidate(new RTCIceCandidate(signal.candidate));
                    } catch (e) {
                        console.error('Error adding received ICE candidate:', e);
                    }
                }
            };
            
            ws.onclose = () => console.log("WebSocket closed.");
            ws.onerror = (err) => console.error("WebSocket error:", err);
            
            sessionStatus.textContent = `Connected to session ${currentSessionId}. WebRTC connecting...`;
            document.getElementById('btnSave').disabled = false;
        }

        function setupPeerConnection(isInitiator) {
            peerConnection = new RTCPeerConnection({
                iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
            });

            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    ws.send(JSON.stringify({ type: 'candidate', candidate: event.candidate }));
                }
            };
            
            peerConnection.onconnectionstatechange = () => {
                webrtcStatus.textContent = peerConnection.connectionState;
                webrtcStatus.style.color = (peerConnection.connectionState === 'connected') ? 'green' : 'red';
            };
            
            if (isInitiator) {
                // Initiator creates the data channel
                dataChannel = peerConnection.createDataChannel('whiteboard-channel');
                dataChannel.onopen = (e) => console.log('Data Channel Open (Initiator)!');
                dataChannel.onmessage = handleRemoteDrawing;
                
                peerConnection.createOffer().then(offer => {
                    peerConnection.setLocalDescription(offer);
                    ws.send(JSON.stringify(offer)); // Send Offer
                });
            } else {
                // Receiver listens for the data channel
                peerConnection.ondatachannel = (event) => {
                    dataChannel = event.channel;
                    dataChannel.onopen = (e) => console.log('Data Channel Open (Receiver)!');
                    dataChannel.onmessage = handleRemoteDrawing;
                };
            }
        }
        
        // --- Initialization and Event Listeners ---
        document.getElementById('btnLogin').addEventListener('click', handleLogin);
        document.getElementById('btnCreate').addEventListener('click', handleCreateSession);
        document.getElementById('btnJoin').addEventListener('click', () => handleJoinSession(false)); 
        document.getElementById('btnSave').addEventListener('click', handleSaveCanvas);
        document.getElementById('btnClear').addEventListener('click', clearCanvas);

        // Tool Switching Logic
        function setTool(toolName) {
            currentTool = toolName;
            document.getElementById('btnPen').classList.remove('active');
            document.getElementById('btnEraser').classList.remove('active');
            document.getElementById(`btn${toolName.charAt(0).toUpperCase() + toolName.slice(1)}`).classList.add('active');
            console.log(`Tool switched to: ${toolName}`);
        }
        document.getElementById('btnPen').addEventListener('click', () => setTool('pen'));
        document.getElementById('btnEraser').addEventListener('click', () => setTool('eraser'));
        
        setupCanvasDrawing(); // Initialize canvas interaction
    </script>
</body>
</html>