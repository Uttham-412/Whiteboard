<!DOCTYPE html>
<html>
<head>
    <title>WebRTC Collaborative Whiteboard</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-1: #0f1020;
            --bg-2: #1a1b3a;
            --bg-3: #0b7285;
            --glass: rgba(255, 255, 255, 0.08);
            --glass-strong: rgba(255, 255, 255, 0.16);
            --border: rgba(255, 255, 255, 0.18);
            --text: #e6e6f0;
            --muted: #a3a7bd;
            --accent: #7c3aed;
            --accent-2: #06b6d4;
            --success: #22c55e;
            --danger: #ef4444;
            --shadow: 0 10px 30px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.06);
            --radius: 16px;
            --radius-sm: 12px;
            --radius-xs: 10px;
            --blur: 16px;
            --transition: 180ms ease;
        }

        * { box-sizing: border-box; }

        body {
            font-family: 'Inter', system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
            color: var(--text);
            min-height: 100svh;
            margin: 0;
            padding: 0;
            background: radial-gradient(1200px 800px at 15% 10%, #1e293b 0%, transparent 60%),
                        radial-gradient(1000px 700px at 85% 20%, rgba(124,58,237,.25) 0%, transparent 60%),
                        radial-gradient(900px 900px at 50% 100%, rgba(6,182,212,.25) 0%, transparent 50%),
                        linear-gradient(160deg, var(--bg-1), var(--bg-2));
            animation: bgShift 14s ease-in-out infinite alternate;
            overflow-x: hidden;
        }

        @keyframes bgShift {
            from { background-position: 0 0, 0 0, 0 0, 0 0; }
            to   { background-position: 10% -5%, -10% 8%, 0% -6%, 0 0; }
        }

        #app-container {
            width: 100%;
            min-height: 100vh;
            background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.05));
            backdrop-filter: blur(var(--blur));
            -webkit-backdrop-filter: blur(var(--blur));
            padding: 0;
            border-radius: 0;
            border: none;
            box-shadow: none;
            position: relative;
            overflow: hidden;
            transform: translateZ(0);
            animation: fadeIn 400ms ease-out both;
            display: flex;
            flex-direction: column;
        }

        #app-container::before {
            content: "";
            position: absolute;
            inset: -2px;
            background: radial-gradient(600px 200px at 20% -10%, rgba(124,58,237,.18) 0%, transparent 60%),
                        radial-gradient(400px 160px at 90% 10%, rgba(6,182,212,.18) 0%, transparent 60%);
            filter: blur(30px);
            z-index: 0;
            pointer-events: none;
        }

        h1 {
            display: none; /* Hidden since we have menu bar now */
        }

        .controls {
            position: relative;
            z-index: 1;
            margin-bottom: 14px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 10px;
            align-items: center;
        }

        .controls input,
        .controls button {
            height: 40px;
            padding: 0 12px;
            border-radius: var(--radius-sm);
            border: 1px solid var(--border);
            outline: none;
            background: linear-gradient(180deg, var(--glass-strong), var(--glass));
            color: var(--text);
            box-shadow: var(--shadow);
            transition: transform var(--transition), box-shadow var(--transition), border-color var(--transition), background var(--transition);
        }

        .controls input::placeholder { color: var(--muted); }

        .controls input:focus {
            border-color: rgba(124,58,237,.6);
            box-shadow: 0 0 0 3px rgba(124,58,237,.18);
        }

        .controls button {
            cursor: pointer;
            background: linear-gradient(180deg, rgba(124,58,237,.28), rgba(124,58,237,.16));
            border: 1px solid rgba(124,58,237,.35);
        }
        .controls button:hover { transform: translateY(-1px); box-shadow: 0 8px 24px rgba(124,58,237,.22); }
        .controls button:active { transform: translateY(0); }
        .controls button.active {
            background: linear-gradient(180deg, rgba(34,197,94,.36), rgba(34,197,94,.2));
            border-color: rgba(34,197,94,.45);
            color: #ecfdf5;
            box-shadow: 0 8px 24px rgba(34,197,94,.24), inset 0 1px 0 rgba(255,255,255,.12);
        }

        .color-picker {
            width: 40px;
            height: 40px;
            padding: 0;
            border: 1px solid var(--border);
            border-radius: 50%;
            overflow: hidden;
            cursor: pointer;
            background: var(--glass);
        }

        /* Range slider */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            border-radius: 999px;
            background: linear-gradient(90deg, rgba(124,58,237,.7), rgba(6,182,212,.7));
            outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px; height: 18px;
            border-radius: 50%;
            background: #fff;
            border: 2px solid rgba(124,58,237,.8);
            box-shadow: 0 2px 8px rgba(0,0,0,.35);
            cursor: pointer;
        }
        input[type="range"]::-moz-range-thumb {
            width: 18px; height: 18px; border-radius: 50%; background: #fff; border: 2px solid rgba(124,58,237,.8);
            box-shadow: 0 2px 8px rgba(0,0,0,.35); cursor: pointer;
        }

        #whiteboard {
            display: block;
            width: 100%;
            max-width: 1000px;
            aspect-ratio: 4 / 3;
            height: auto;
            max-height: 72vh;
            border-radius: var(--radius);
            border: 1px solid var(--border);
            background: linear-gradient(180deg, rgba(255,255,255,.9), rgba(255,255,255,.75));
            box-shadow: 0 20px 40px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.5);
            cursor: crosshair;
            image-rendering: -webkit-optimize-contrast;
            transition: transform var(--transition), box-shadow var(--transition);
            position: relative;
            z-index: 1;
        }
        #whiteboard:hover { transform: translateY(-2px); box-shadow: 0 28px 60px rgba(0,0,0,.4), inset 0 1px 0 rgba(255,255,255,.5); }

        .status-bar {
            margin-top: 14px;
            font-size: 0.9em;
            color: var(--muted);
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }
        .status-bar span {
            padding: 6px 10px;
            border-radius: var(--radius-xs);
            background: linear-gradient(180deg, var(--glass-strong), var(--glass));
            border: 1px solid var(--border);
            color: var(--text);
        }
        #webrtcStatus { color: var(--danger); }

        @keyframes fadeIn { from { opacity: 0; transform: translateY(6px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes titleFloat { 0%,100% { transform: translateY(0); } 50% { transform: translateY(-4px); } }
        @keyframes fadeInUp { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        /* Subtle stagger for controls */
        .controls { animation: fadeInUp 420ms ease both; }
        .controls:nth-of-type(1) { animation-delay: 60ms; }
        .controls:nth-of-type(2) { animation-delay: 120ms; }
        .controls:nth-of-type(3) { animation-delay: 180ms; }

        /* Menu Bar */
        .menu-bar {
            display: flex;
            align-items: center;
            padding: 8px 16px;
            background: linear-gradient(180deg, var(--glass-strong), var(--glass));
            border-bottom: 1px solid var(--border);
            gap: 24px;
            position: relative;
            z-index: 10;
        }
        .menu-item {
            background: none;
            border: none;
            color: var(--text);
            cursor: pointer;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 14px;
            transition: background var(--transition);
        }
        .menu-item:hover { background: var(--glass); }
        .toolbar {
            display: flex;
            align-items: center;
            padding: 8px 16px;
            gap: 8px;
            background: linear-gradient(180deg, var(--glass-strong), var(--glass));
            border-bottom: 1px solid var(--border);
            position: relative;
            z-index: 10;
        }
        .toolbar-btn {
            width: 32px;
            height: 32px;
            border: 1px solid var(--border);
            background: var(--glass);
            color: var(--text);
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all var(--transition);
        }
        .toolbar-btn:hover { background: var(--glass-strong); transform: translateY(-1px); }
        .toolbar-btn:disabled { opacity: 0.5; cursor: not-allowed; }

        /* Ribbon Toolbar */
        .ribbon {
            background: linear-gradient(180deg, var(--glass-strong), var(--glass));
            border-bottom: 1px solid var(--border);
            padding: 12px 16px;
            position: relative;
            z-index: 10;
        }
        .ribbon-section {
            display: inline-flex;
            flex-direction: column;
            margin-right: 24px;
            vertical-align: top;
        }
        .ribbon-section-title {
            font-size: 11px;
            color: var(--muted);
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .ribbon-buttons {
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
        }
        .ribbon-btn {
            width: 36px;
            height: 36px;
            border: 1px solid var(--border);
            background: var(--glass);
            color: var(--text);
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            transition: all var(--transition);
            position: relative;
        }
        .ribbon-btn:hover { background: var(--glass-strong); }
        .ribbon-btn.active {
            background: linear-gradient(180deg, rgba(124,58,237,.4), rgba(124,58,237,.2));
            border-color: rgba(124,58,237,.6);
        }
        .ribbon-btn-grid {
            display: grid;
            grid-template-columns: repeat(4, 36px);
            gap: 4px;
        }

        /* Color Palette */
        .color-palette {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }
        .color-swatch {
            width: 28px;
            height: 28px;
            border-radius: 4px;
            border: 2px solid var(--border);
            cursor: pointer;
            transition: transform var(--transition), box-shadow var(--transition);
        }
        .color-swatch:hover { transform: scale(1.1); box-shadow: 0 2px 8px rgba(0,0,0,.3); }
        .color-swatch.active { border-color: #fff; box-shadow: 0 0 0 2px var(--accent); }

        /* Left Sidebar */
        .left-sidebar {
            position: fixed;
            left: 0;
            top: 0;
            bottom: 0;
            width: 48px;
            background: linear-gradient(180deg, var(--glass-strong), var(--glass));
            border-right: 1px solid var(--border);
            padding: 16px 8px;
            display: flex;
            flex-direction: column;
            gap: 24px;
            z-index: 100;
        }
        .vertical-slider {
            writing-mode: vertical-lr;
            height: 200px;
            width: 24px;
        }
        .slider-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }
        .slider-icon {
            font-size: 20px;
            color: var(--muted);
        }

        /* Canvas Container with Zoom */
        .canvas-container {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            overflow: auto;
            flex: 1;
            background: var(--bg-2);
        }
        .canvas-wrapper {
            position: relative;
            display: inline-block;
        }

        /* Enhanced Status Bar */
        .status-bar-enhanced {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 16px;
            background: linear-gradient(180deg, var(--glass-strong), var(--glass));
            border-top: 1px solid var(--border);
            font-size: 12px;
            gap: 16px;
        }
        .status-left, .status-right {
            display: flex;
            gap: 16px;
            align-items: center;
        }
        .zoom-control {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .zoom-slider {
            width: 100px;
            height: 4px;
        }

        /* Shape Preview */
        .shape-preview {
            position: absolute;
            pointer-events: none;
            border: 2px dashed var(--accent);
        }

        /* Text Input Overlay */
        .text-input-overlay {
            position: absolute;
            border: 2px solid var(--accent);
            padding: 4px;
            background: rgba(255,255,255,0.9);
            color: #000;
            font-family: Arial, sans-serif;
            min-width: 100px;
            min-height: 24px;
            resize: both;
            overflow: hidden;
        }

        /* Hide session controls when not needed */
        .session-controls {
            margin-bottom: 12px;
        }
    </style>
</head>
<body>
    <div id="app-container">
        <!-- Ribbon Toolbar -->
        <div class="ribbon">
            <div class="ribbon-section">
                <div class="ribbon-section-title">Tools</div>
                <div class="ribbon-buttons">
                    <button class="ribbon-btn active" id="toolPen" title="Pen">‚úèÔ∏è</button>
                    <button class="ribbon-btn" id="toolEraser" title="Eraser">üßπ</button>
                    <button class="ribbon-btn" id="toolText" title="Text">A</button>
                    <button class="ribbon-btn" id="toolEyedropper" title="Eyedropper">üëÅÔ∏è</button>
                    <button class="ribbon-btn" id="toolZoom" title="Zoom">üîç</button>
                </div>
            </div>
            <div class="ribbon-section">
                <div class="ribbon-section-title">Brushes</div>
                <div class="ribbon-btn-grid">
                    <button class="ribbon-btn brush-style" data-style="solid" title="Solid">‚îÅ</button>
                    <button class="ribbon-btn brush-style" data-style="dashed" title="Dashed">‚îâ</button>
                    <button class="ribbon-btn brush-style active" data-style="dotted" title="Dotted">‚îÑ</button>
                    <button class="ribbon-btn brush-style" data-style="wavy" title="Wavy">‚âà</button>
                </div>
            </div>
            <div class="ribbon-section">
                <div class="ribbon-section-title">Shapes</div>
                <div class="ribbon-btn-grid">
                    <button class="ribbon-btn shape-tool" data-shape="circle" title="Circle">‚óã</button>
                    <button class="ribbon-btn shape-tool" data-shape="square" title="Square">‚ñ°</button>
                    <button class="ribbon-btn shape-tool" data-shape="triangle" title="Triangle">‚ñ≥</button>
                    <button class="ribbon-btn shape-tool" data-shape="arrow" title="Arrow">‚Üí</button>
                    <button class="ribbon-btn shape-tool" data-shape="speech" title="Speech Bubble">üí¨</button>
                    <button class="ribbon-btn shape-tool" data-shape="star" title="Star">‚òÖ</button>
                </div>
            </div>
            <div class="ribbon-section">
                <div class="ribbon-section-title">Colours</div>
                <div class="color-palette" id="colorPalette">
                    <div class="color-swatch active" data-color="#000000" style="background: #000000"></div>
                    <div class="color-swatch" data-color="#ffffff" style="background: #ffffff"></div>
                    <div class="color-swatch" data-color="#808080" style="background: #808080"></div>
                    <div class="color-swatch" data-color="#ff0000" style="background: #ff0000"></div>
                    <div class="color-swatch" data-color="#ff8800" style="background: #ff8800"></div>
                    <div class="color-swatch" data-color="#ffff00" style="background: #ffff00"></div>
                    <div class="color-swatch" data-color="#00ff00" style="background: #00ff00"></div>
                    <div class="color-swatch" data-color="#00ffff" style="background: #00ffff"></div>
                    <div class="color-swatch" data-color="#0000ff" style="background: #0000ff"></div>
                    <div class="color-swatch" data-color="#8800ff" style="background: #8800ff"></div>
                    <div class="color-swatch" data-color="#ffaaaa" style="background: #ffaaaa"></div>
                    <div class="color-swatch" data-color="#ffcc88" style="background: #ffcc88"></div>
                    <div class="color-swatch" data-color="#ffffaa" style="background: #ffffaa"></div>
                    <div class="color-swatch" data-color="#aaffaa" style="background: #aaffaa"></div>
                    <div class="color-swatch" data-color="#aaffff" style="background: #aaffff"></div>
                    <div class="color-swatch" data-color="#aaaaff" style="background: #aaaaff"></div>
                    <input type="color" id="colorPicker" class="color-picker" value="#000000" style="width: 28px; height: 28px; border-radius: 4px;">
                </div>
            </div>
        </div>

        <!-- Session Controls (Collapsible) -->
        <div class="session-controls controls">
            <input type="text" id="username" placeholder="Username" value="user_A">
            <button id="btnLogin">Login</button>
            <span id="authStatus">Not logged in.</span>
            <button id="btnCreate">Create Session</button>
            <input type="text" id="sessionIdInput" placeholder="Session ID">
            <button id="btnJoin" disabled>Join Session</button>
            <button id="btnSave" disabled>Save Canvas</button>
            <button id="btnClear">Clear</button>
            <label style="display: flex; align-items: center; gap: 8px;">
                Size: <input type="range" id="sizeSlider" min="1" max="50" value="5" style="width: 100px;">
            </label>
            <label style="display: flex; align-items: center; gap: 8px;">
                Opacity: <input type="range" id="opacitySlider" min="0" max="100" value="100" style="width: 100px;">
            </label>
        </div>

        <!-- Canvas Container -->
        <div class="canvas-container">
            <div class="canvas-wrapper">
                <canvas id="whiteboard" width="800" height="600"></canvas>
            </div>
        </div>

        <!-- Enhanced Status Bar -->
        <div class="status-bar-enhanced">
            <div class="status-left">
                <span>üñ±Ô∏è</span>
                <span id="cursorPosition">X: 0, Y: 0</span>
                <span>üìê</span>
                <span id="canvasDimensions">800 x 600px</span>
                <span id="sessionStatus">Session: N/A</span>
            </div>
            <div class="status-right">
                <span id="webrtcStatus" style="color: red;">Disconnected</span>
                <span id="currentUserName">User: -</span>
                <div class="zoom-control">
                    <button id="zoomOut" class="toolbar-btn">‚àí</button>
                    <input type="range" id="zoomSlider" class="zoom-slider" min="25" max="200" value="100">
                    <button id="zoomIn" class="toolbar-btn">+</button>
                    <span id="zoomPercent">100%</span>
                </div>
                <button id="fitToScreen" class="toolbar-btn" title="Fit to Screen">‚§¢</button>
            </div>
        </div>
    </div>

    <script>
        // --- Global State ---
        const CANVAS_WIDTH = 800;
        const CANVAS_HEIGHT = 600;
        const canvas = document.getElementById('whiteboard');
        const ctx = canvas.getContext('2d');
        
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let drawingHistory = []; 
        let currentTool = 'pen';
        let currentBrushStyle = 'solid';
        let currentShape = null;
        let shapeStartX = 0;
        let shapeStartY = 0;
        let currentOpacity = 1;
        
        // Undo/Redo stacks
        let undoStack = [];
        let redoStack = [];
        
        // Zoom state
        let zoomLevel = 1;
        
        // Text tool state
        let textInputElement = null;
        
        // Canvas state for undo/redo
        let historyStates = [];
        
        let peerConnection;
        let dataChannel;
        let ws; 
        
        // App State
        let currentToken = null;
        let currentSessionId = null;
        let currentUserName = '';

        // --- DEPLOYMENT CONFIGURATION ---
        // IMPORTANT: CHANGE 'localhost:8000' to your deployed server address (e.g., 'https://my-app.com')
        // index.html <script>
// The browser will automatically handle the 'https://' and 'wss://'
        const DEPLOYED_HOST = 'whiteboard-axcw.onrender.com'; 
// ... the rest of your code ... 
        const PROTOCOL = DEPLOYED_HOST.startsWith('localhost') ? 'http' : 'https';
        const WS_PROTOCOL = DEPLOYED_HOST.startsWith('localhost') ? 'ws' : 'wss';
        const API_BASE = `${PROTOCOL}://${DEPLOYED_HOST}/api`; 

        // --- UI Element References ---
        const authStatus = document.getElementById('authStatus');
        const sessionStatus = document.getElementById('sessionStatus');
        const webrtcStatus = document.getElementById('webrtcStatus');
        const currentUserNameEl = document.getElementById('currentUserName');
        const sessionIdInput = document.getElementById('sessionIdInput');
        
        // --- API & Auth Helpers ---
        function getAuthHeaders() {
            return {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${currentToken}`
            };
        }

        async function handleLogin() {
            const username = document.getElementById('username').value;
            if (!username) return alert("Please enter a username.");

            try {
                const response = await fetch(`${API_BASE}/login`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ username })
                });

                if (response.ok) {
                    const data = await response.json();
                    currentToken = data.access_token;
                    currentUserName = data.username;
                    authStatus.textContent = `Logged in as: ${currentUserName}`;
                    currentUserNameEl.textContent = currentUserName;
                    document.getElementById('btnJoin').disabled = false;
                    document.getElementById('btnCreate').disabled = false;
                } else {
                    alert("Login failed.");
                }
            } catch (error) {
                console.error('Login error:', error);
                alert("Login failed. Check server address/CORS or if the FastAPI server is running.");
            }
        }

        async function handleCreateSession() {
            if (!currentToken) return alert("Please log in first.");

            try {
                const response = await fetch(`${API_BASE}/sessions`, {
                    method: 'POST',
                    headers: getAuthHeaders()
                });

                if (response.ok) {
                    const session = await response.json();
                    currentSessionId = session.session_id;
                    sessionIdInput.value = currentSessionId;
                    handleJoinSession(true); // Auto-join and set as initiator
                } else {
                    alert("Failed to create session.");
                }
            } catch (error) {
                console.error('Create session error:', error);
            }
        }
        
        async function handleSaveCanvas() {
            if (!currentToken || !currentSessionId) {
                alert("Please join a session first.");
                return;
            }
            
            if (drawingHistory.length === 0) {
                alert("Nothing to save - canvas is empty.");
                return;
            }
            
            // Disable save button during save operation
            const saveBtn = document.getElementById('btnSave');
            saveBtn.disabled = true;
            sessionStatus.textContent = "Saving canvas...";
            
            try {
                console.log(`Saving ${drawingHistory.length} drawing commands to session ${currentSessionId}`);
                
                const response = await fetch(`${API_BASE}/sessions/${currentSessionId}/save`, {
                    method: 'POST',
                    headers: getAuthHeaders(),
                    body: JSON.stringify(drawingHistory) // Send the entire history array
                });

                if (response.status === 204) {
                    sessionStatus.textContent = `‚úì Session ${currentSessionId} saved successfully!`;
                    console.log("Canvas saved successfully!");
                } else if (response.status === 404) {
                    const errorData = await response.json().catch(() => ({ detail: "Session not found" }));
                    alert(`Session not found: ${errorData.detail || "Please create or join a session first."}`);
                    sessionStatus.textContent = "Save failed: Session not found.";
                } else if (response.status === 401) {
                    alert("Authentication failed. Please log in again.");
                    sessionStatus.textContent = "Save failed: Authentication error.";
                } else if (response.status === 422) {
                    const errorData = await response.json().catch(() => ({ detail: "Validation error" }));
                    console.error("Validation error:", errorData);
                    alert(`Failed to save: ${errorData.detail || "Invalid data format."}`);
                    sessionStatus.textContent = "Save failed: Validation error.";
                } else {
                    const errorText = await response.text().catch(() => "Unknown error");
                    console.error("Save failed with status:", response.status, errorText);
                    alert(`Failed to save canvas state. Status: ${response.status}`);
                    sessionStatus.textContent = `Save failed (Status: ${response.status}).`;
                }
            } catch (error) {
                console.error('Save error:', error);
                alert(`Failed to save canvas: ${error.message || "Network error. Check console for details."}`);
                sessionStatus.textContent = "Save failed: Network error.";
            } finally {
                saveBtn.disabled = false;
            }
        }

        function clearCanvas() {
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            drawingHistory = []; // Clear local history
            sessionStatus.textContent = `Canvas cleared locally. (Must save to persist!)`;
        }

        // --- Canvas Drawing Logic ---
        function drawLine(x1, y1, x2, y2, color, size, tool) {
            drawLineEnhanced(x1, y1, x2, y2, color, size, tool);
        }

        function handleRemoteDrawing(event) {
            try {
                const cmd = JSON.parse(event.data);
                if (cmd.x1 !== undefined) {
                    drawLine(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.color, cmd.size, cmd.tool);
                    drawingHistory.push(cmd); // Add remote command to history
                }
            } catch (e) {
                console.error("Failed to parse remote drawing data:", e);
            }
        }

        function setupCanvasDrawing() {
            // Verify canvas and context are available
            if (!canvas || !ctx) {
                console.error('Canvas or context not available!');
                return;
            }

            // Helper function to get accurate canvas coordinates
            function getCanvasCoordinates(e) {
                const rect = canvas.getBoundingClientRect();
                if (rect.width === 0 || rect.height === 0) {
                    console.warn('Canvas has zero dimensions');
                    return { x: 0, y: 0 };
                }
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                return {
                    x: (e.clientX - rect.left) * scaleX,
                    y: (e.clientY - rect.top) * scaleY
                };
            }

            canvas.addEventListener('mousedown', (e) => {
                e.preventDefault();
                const coords = getCanvasCoordinates(e);
                
                if (currentTool === 'text') {
                    addText(coords.x, coords.y);
                    return;
                }
                
                if (currentTool === 'eyedropper') {
                    const color = getColorAt(Math.round(coords.x), Math.round(coords.y));
                    document.getElementById('colorPicker').value = color;
                    document.querySelectorAll('.color-swatch').forEach(s => {
                        if (s.dataset.color.toLowerCase() === color.toLowerCase()) s.classList.add('active');
                        else s.classList.remove('active');
                    });
                    setTool('pen'); // Switch back to pen after picking color
                    return;
                }
                
                if (currentTool === 'zoom') {
                    const delta = e.shiftKey ? -10 : 10;
                    setZoom(Math.max(25, Math.min(200, zoomLevel * 100 + delta)));
                    return;
                }
                
                if (currentTool === 'shape' && currentShape) {
                    isDrawing = true;
                    shapeStartX = coords.x;
                    shapeStartY = coords.y;
                    return;
                }
                
                isDrawing = true;
                [lastX, lastY] = [coords.x, coords.y];
                saveState(); // Save state before drawing
            });

            canvas.addEventListener('mousemove', (e) => {
                const coords = getCanvasCoordinates(e);
                updateCursorPosition(e);
                
                if (!isDrawing) return;
                
                const color = document.getElementById('colorPicker')?.value || '#000000';
                const size = Number.parseInt(document.getElementById('sizeSlider')?.value || '5', 10);

                // Handle shape drawing
                if (currentTool === 'shape' && currentShape) {
                    // Redraw canvas without current shape for preview
                    // In a real implementation, you'd use a temp canvas for preview
                    return;
                }
                
                // For the eraser, use a white stroke color or the canvas background color
                const strokeColor = (currentTool === 'eraser') ? 'white' : color;
                
                // Draw locally using enhanced draw function
                drawLineEnhanced(lastX, lastY, coords.x, coords.y, strokeColor, size, currentTool);
                
                const command = {
                    x1: lastX, y1: lastY, 
                    x2: coords.x, y2: coords.y, 
                    color: strokeColor, 
                    size: size,
                    tool: currentTool
                };

                // Add to history and send via WebRTC Data Channel (only if session is active)
                drawingHistory.push(command); 
                if (dataChannel && dataChannel.readyState === 'open') {
                    dataChannel.send(JSON.stringify(command));
                }

                [lastX, lastY] = [coords.x, coords.y];
            });

            canvas.addEventListener('mouseup', (e) => {
                if (!isDrawing) return;
                
                const coords = getCanvasCoordinates(e);
                const color = document.getElementById('colorPicker')?.value || '#000000';
                const size = Number.parseInt(document.getElementById('sizeSlider')?.value || '5', 10);
                
                // Handle shape drawing completion
                if (currentTool === 'shape' && currentShape) {
                    drawShape(currentShape, shapeStartX, shapeStartY, coords.x, coords.y, color, size);
                    saveState();
                    drawingHistory.push({
                        type: 'shape',
                        shape: currentShape,
                        x1: shapeStartX, y1: shapeStartY,
                        x2: coords.x, y2: coords.y,
                        color: color,
                        size: size
                    });
                }
                
                isDrawing = false;
            });
            
            canvas.addEventListener('mouseout', () => {
                if (isDrawing) {
                    isDrawing = false;
                }
                updateCursorPosition({ clientX: -1, clientY: -1 });
            });
            
            // Touch support for mobile devices
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const coords = getCanvasCoordinates(touch);
                isDrawing = true;
                [lastX, lastY] = [coords.x, coords.y];
            });

            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (!isDrawing) return;
                
                const touch = e.touches[0];
                const coords = getCanvasCoordinates(touch);
                const currentX = coords.x;
                const currentY = coords.y;
                
                const color = document.getElementById('colorPicker').value;
                const size = Number.parseInt(document.getElementById('sizeSlider').value, 10);
                const strokeColor = (currentTool === 'eraser') ? 'white' : color;
                
                drawLine(lastX, lastY, currentX, currentY, strokeColor, size, currentTool);
                
                const command = {
                    x1: lastX, y1: lastY,
                    x2: currentX, y2: currentY,
                    color: strokeColor,
                    size: size,
                    tool: currentTool
                };

                drawingHistory.push(command);
                if (dataChannel && dataChannel.readyState === 'open') {
                    dataChannel.send(JSON.stringify(command));
                }

                lastX = currentX;
                lastY = currentY;
            });

            canvas.addEventListener('touchend', () => isDrawing = false);
            canvas.addEventListener('touchcancel', () => isDrawing = false);
        }

        function loadCanvasState(commands) {
            // Clear and reset state before loading
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            drawingHistory = []; 
            
            commands.forEach(cmd => {
                drawLine(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.color, cmd.size, cmd.tool);
                drawingHistory.push(cmd);
            });
            console.log(`Loaded ${commands.length} drawing commands.`);
        }

        // --- WebRTC Signaling and Peer Connection ---
        
        async function handleJoinSession(isInitiator = false) {
            currentSessionId = sessionIdInput.value.trim();
            if (!currentSessionId) return alert("Please enter a Session ID.");
            if (!currentToken) return alert("Please log in first.");

            sessionStatus.textContent = `Joining session: ${currentSessionId}...`;
            document.getElementById('btnSave').disabled = true;

            // 1. Load Initial Canvas State from API
            try {
                const response = await fetch(`${API_BASE}/sessions/${currentSessionId}`, { headers: getAuthHeaders() });
                if (!response.ok) throw new Error("Session load failed.");
                const sessionData = await response.json();
                loadCanvasState(sessionData.canvas_state); // Restore drawing
            } catch (error) {
                console.error("Error loading session:", error);
                sessionStatus.textContent = `Session ${currentSessionId} load failed. Check ID and server logs.`;
                return;
            }
            
            // 2. Setup WebSocket for Signaling
            ws = new WebSocket(`${WS_PROTOCOL}://${DEPLOYED_HOST}/ws/${currentSessionId}`);
            
            ws.onopen = () => {
                console.log("WebSocket connected. Starting WebRTC signaling...");
                setupPeerConnection(isInitiator);
            };
            
            // WebSocket Message Handler (Signaling Exchange)
            ws.onmessage = async (event) => {
                const signal = JSON.parse(event.data);

                if (signal.type === 'offer') {
                    await peerConnection.setRemoteDescription(new RTCSessionDescription(signal));
                    const answer = await peerConnection.createAnswer();
                    await peerConnection.setLocalDescription(answer);
                    ws.send(JSON.stringify(peerConnection.localDescription)); // Send Answer back
                } else if (signal.type === 'answer') {
                    await peerConnection.setRemoteDescription(new RTCSessionDescription(signal));
                } else if (signal.type === 'candidate') {
                    try {
                        await peerConnection.addIceCandidate(new RTCIceCandidate(signal.candidate));
                    } catch (e) {
                        console.error('Error adding received ICE candidate:', e);
                    }
                }
            };
            
            ws.onclose = () => console.log("WebSocket closed.");
            ws.onerror = (err) => console.error("WebSocket error:", err);
            
            sessionStatus.textContent = `Connected to session ${currentSessionId}. WebRTC connecting...`;
            document.getElementById('btnSave').disabled = false;
        }

        function setupPeerConnection(isInitiator) {
            peerConnection = new RTCPeerConnection({
                iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
            });

            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    ws.send(JSON.stringify({ type: 'candidate', candidate: event.candidate }));
                }
            };
            
            peerConnection.onconnectionstatechange = () => {
                webrtcStatus.textContent = peerConnection.connectionState;
                webrtcStatus.style.color = (peerConnection.connectionState === 'connected') ? 'green' : 'red';
            };
            
            if (isInitiator) {
                // Initiator creates the data channel
                dataChannel = peerConnection.createDataChannel('whiteboard-channel');
                dataChannel.onopen = (e) => console.log('Data Channel Open (Initiator)!');
                dataChannel.onmessage = handleRemoteDrawing;
                
                peerConnection.createOffer().then(offer => {
                    peerConnection.setLocalDescription(offer);
                    ws.send(JSON.stringify(offer)); // Send Offer
                });
            } else {
                // Receiver listens for the data channel
                peerConnection.ondatachannel = (event) => {
                    dataChannel = event.channel;
                    dataChannel.onopen = (e) => console.log('Data Channel Open (Receiver)!');
                    dataChannel.onmessage = handleRemoteDrawing;
                };
            }
        }
        
        // --- Advanced Drawing Features ---

        // Undo/Redo functionality
        function saveState() {
            const imageData = ctx.getImageData(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            undoStack.push(imageData);
            redoStack = []; // Clear redo stack when new action is performed
            if (undoStack.length > 50) undoStack.shift(); // Limit history
        }

        function undo() {
            if (undoStack.length === 0) return;
            const currentState = ctx.getImageData(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            redoStack.push(currentState);
            const previousState = undoStack.pop();
            ctx.putImageData(previousState, 0, 0);
        }

        function redo() {
            if (redoStack.length === 0) return;
            const currentState = ctx.getImageData(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            undoStack.push(currentState);
            const nextState = redoStack.pop();
            ctx.putImageData(nextState, 0, 0);
        }

        // Shape drawing functions
        function drawShape(shape, x1, y1, x2, y2, color, size) {
            ctx.save();
            ctx.globalAlpha = currentOpacity;
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = size;
            ctx.beginPath();

            const width = Math.abs(x2 - x1);
            const height = Math.abs(y2 - y1);
            const centerX = (x1 + x2) / 2;
            const centerY = (y1 + y2) / 2;

            switch(shape) {
                case 'circle':
                    ctx.arc(centerX, centerY, Math.max(width, height) / 2, 0, 2 * Math.PI);
                    break;
                case 'square':
                    ctx.rect(Math.min(x1, x2), Math.min(y1, y2), width, height);
                    break;
                case 'triangle':
                    ctx.moveTo(centerX, Math.min(y1, y2));
                    ctx.lineTo(Math.min(x1, x2), Math.max(y1, y2));
                    ctx.lineTo(Math.max(x1, x2), Math.max(y1, y2));
                    ctx.closePath();
                    break;
                case 'arrow': {
                    const dx = x2 - x1;
                    const dy = y2 - y1;
                    const angle = Math.atan2(dy, dx);
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.lineTo(x2 - 15 * Math.cos(angle - Math.PI / 6), y2 - 15 * Math.sin(angle - Math.PI / 6));
                    ctx.moveTo(x2, y2);
                    ctx.lineTo(x2 - 15 * Math.cos(angle + Math.PI / 6), y2 - 15 * Math.sin(angle + Math.PI / 6));
                    break;
                }
                case 'speech': {
                    const r = Math.min(width, height) / 4;
                    ctx.arc(centerX, centerY, r, 0, 2 * Math.PI);
                    ctx.moveTo(centerX + r * 0.7, centerY + r * 0.7);
                    ctx.lineTo(centerX + r, centerY + r * 1.5);
                    ctx.lineTo(centerX + r * 1.3, centerY + r * 0.7);
                    break;
                }
                case 'star': {
                    const outerRadius = Math.max(width, height) / 2;
                    const innerRadius = outerRadius / 2;
                    for (let i = 0; i < 5; i++) {
                        const angle = (i * 4 * Math.PI / 5) - Math.PI / 2;
                        const x = centerX + outerRadius * Math.cos(angle);
                        const y = centerY + outerRadius * Math.sin(angle);
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                        const innerAngle = angle + (2 * Math.PI / 5);
                        ctx.lineTo(centerX + innerRadius * Math.cos(innerAngle), centerY + innerRadius * Math.sin(innerAngle));
                    }
                    ctx.closePath();
                    break;
                }
            }
            ctx.stroke();
            ctx.restore();
        }

        // Brush style implementation
        function applyBrushStyle() {
            switch(currentBrushStyle) {
                case 'dashed':
                    ctx.setLineDash([5, 5]);
                    break;
                case 'dotted':
                    ctx.setLineDash([2, 8]);
                    break;
                case 'wavy':
                    ctx.setLineDash([3, 3, 1, 3]);
                    break;
                default:
                    ctx.setLineDash([]);
            }
        }

        // Enhanced drawLine with brush styles
        function drawLineEnhanced(x1, y1, x2, y2, color, size, tool) {
            if (!ctx) return;
            ctx.save();
            ctx.beginPath();
            ctx.globalCompositeOperation = (tool === 'eraser') ? 'destination-out' : 'source-over';
            ctx.globalAlpha = currentOpacity;
            ctx.strokeStyle = color;
            ctx.lineWidth = size;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            applyBrushStyle();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
            ctx.restore();
        }

        // Text tool
        function addText(x, y) {
            if (textInputElement) textInputElement.remove();
            
            const rect = canvas.getBoundingClientRect();
            const input = document.createElement('textarea');
            input.className = 'text-input-overlay';
            input.style.left = (rect.left + x) + 'px';
            input.style.top = (rect.top + y) + 'px';
            input.style.fontSize = '16px';
            input.style.border = '2px solid var(--accent)';
            input.placeholder = 'Type text...';
            
            input.addEventListener('blur', () => {
                const text = input.value;
                if (text) {
                    ctx.save();
                    ctx.font = '16px Arial';
                    ctx.fillStyle = document.getElementById('colorPicker').value;
                    ctx.globalAlpha = currentOpacity;
                    ctx.fillText(text, x, y);
                    ctx.restore();
                    saveState();
                }
                input.remove();
                textInputElement = null;
            });
            
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    input.blur();
                }
            });
            
            document.body.appendChild(input);
            input.focus();
            textInputElement = input;
        }

        // Eyedropper tool
        function getColorAt(x, y) {
            const imageData = ctx.getImageData(x, y, 1, 1);
            const [r, g, b] = imageData.data;
            return `#${[r, g, b].map(v => v.toString(16).padStart(2, '0')).join('')}`;
        }

        // Zoom functionality
        function setZoom(level) {
            zoomLevel = level / 100;
            const wrapper = document.querySelector('.canvas-wrapper');
            wrapper.style.transform = `scale(${zoomLevel})`;
            wrapper.style.transformOrigin = 'center';
            document.getElementById('zoomPercent').textContent = Math.round(level) + '%';
            document.getElementById('zoomSlider').value = level;
        }

        // Update cursor position in status bar
        function updateCursorPosition(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = Math.round((e.clientX - rect.left) * scaleX);
            const y = Math.round((e.clientY - rect.top) * scaleY);
            document.getElementById('cursorPosition').textContent = `X: ${x}, Y: ${y}`;
        }

        // --- Initialization and Event Listeners ---
        document.getElementById('btnLogin').addEventListener('click', handleLogin);
        document.getElementById('btnCreate').addEventListener('click', handleCreateSession);
        document.getElementById('btnJoin').addEventListener('click', () => handleJoinSession(false)); 
        document.getElementById('btnSave').addEventListener('click', handleSaveCanvas);
        document.getElementById('btnClear').addEventListener('click', clearCanvas);

        // Tool Switching Logic
        function setTool(toolName) {
            currentTool = toolName;
            currentShape = null;
            
            // Update ribbon buttons
            document.querySelectorAll('.ribbon-btn').forEach(btn => btn.classList.remove('active'));
            
            if (toolName === 'pen') document.getElementById('toolPen')?.classList.add('active');
            else if (toolName === 'eraser') document.getElementById('toolEraser')?.classList.add('active');
            else if (toolName === 'text') document.getElementById('toolText')?.classList.add('active');
            else if (toolName === 'eyedropper') document.getElementById('toolEyedropper')?.classList.add('active');
            else if (toolName === 'zoom') document.getElementById('toolZoom')?.classList.add('active');
            
            // Update cursor
            if (toolName === 'eyedropper') canvas.style.cursor = 'crosshair';
            else if (toolName === 'zoom') canvas.style.cursor = 'zoom-in';
            else if (toolName === 'text') canvas.style.cursor = 'text';
            else canvas.style.cursor = 'crosshair';
            
            console.log(`Tool switched to: ${toolName}`);
        }

        // Ribbon tool buttons
        document.getElementById('toolPen')?.addEventListener('click', () => setTool('pen'));
        document.getElementById('toolEraser')?.addEventListener('click', () => setTool('eraser'));
        document.getElementById('toolText')?.addEventListener('click', () => setTool('text'));
        document.getElementById('toolEyedropper')?.addEventListener('click', () => setTool('eyedropper'));
        document.getElementById('toolZoom')?.addEventListener('click', () => setTool('zoom'));

        // Brush style buttons
        document.querySelectorAll('.brush-style').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.brush-style').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentBrushStyle = btn.dataset.style;
            });
        });

        // Shape tool buttons
        document.querySelectorAll('.shape-tool').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.shape-tool').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentShape = btn.dataset.shape;
                currentTool = 'shape';
            });
        });

        // Color palette
        document.querySelectorAll('.color-swatch').forEach(swatch => {
            swatch.addEventListener('click', () => {
                document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('active'));
                swatch.classList.add('active');
                const color = swatch.dataset.color;
                document.getElementById('colorPicker').value = color;
            });
        });

        document.getElementById('colorPicker').addEventListener('change', (e) => {
            const color = e.target.value;
            document.querySelectorAll('.color-swatch').forEach(s => {
                if (s.dataset.color === color) s.classList.add('active');
                else s.classList.remove('active');
            });
        });

        // Size and Opacity sliders
        document.getElementById('opacitySlider')?.addEventListener('input', (e) => {
            currentOpacity = e.target.value / 100;
        });

        // Zoom controls
        document.getElementById('zoomSlider')?.addEventListener('input', (e) => {
            setZoom(Number.parseInt(e.target.value, 10));
        });
        document.getElementById('zoomIn')?.addEventListener('click', () => {
            setZoom(Math.min(200, zoomLevel * 100 + 10));
        });
        document.getElementById('zoomOut')?.addEventListener('click', () => {
            setZoom(Math.max(25, zoomLevel * 100 - 10));
        });
        document.getElementById('fitToScreen')?.addEventListener('click', () => {
            setZoom(100);
        });

        // Legacy tool buttons (for compatibility)
        const btnPen = document.getElementById('btnPen');
        const btnEraser = document.getElementById('btnEraser');
        if (btnPen) btnPen.addEventListener('click', () => setTool('pen'));
        if (btnEraser) btnEraser.addEventListener('click', () => setTool('eraser'));
        
        // Update canvas dimensions display
        document.getElementById('canvasDimensions').textContent = `${CANVAS_WIDTH} x ${CANVAS_HEIGHT}px`;
        
        // Initialize canvas interaction after DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', setupCanvasDrawing);
        } else {
            setupCanvasDrawing();
        }
        
        // Initialize zoom
        setZoom(100);
        
        console.log('Canvas initialized:', canvas, 'Context:', ctx);
    </script>
</body>
</html>