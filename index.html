<!DOCTYPE html>
<html>
<head>
    <title>WebRTC Collaborative Whiteboard</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-1: #0f1020;
            --bg-2: #1a1b3a;
            --bg-3: #0b7285;
            --glass: rgba(255, 255, 255, 0.08);
            --glass-strong: rgba(255, 255, 255, 0.16);
            --border: rgba(255, 255, 255, 0.18);
            --text: #e6e6f0;
            --muted: #a3a7bd;
            --accent: #7c3aed;
            --accent-2: #06b6d4;
            --success: #22c55e;
            --danger: #ef4444;
            --shadow: 0 10px 30px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.06);
            --radius: 16px;
            --radius-sm: 12px;
            --radius-xs: 10px;
            --blur: 16px;
            --transition: 180ms ease;
        }

        * { box-sizing: border-box; }

        body {
            font-family: 'Inter', system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
            color: var(--text);
            min-height: 100svh;
            display: grid;
            place-items: center;
            margin: 0;
            padding: 32px;
            background: radial-gradient(1200px 800px at 15% 10%, #1e293b 0%, transparent 60%),
                        radial-gradient(1000px 700px at 85% 20%, rgba(124,58,237,.25) 0%, transparent 60%),
                        radial-gradient(900px 900px at 50% 100%, rgba(6,182,212,.25) 0%, transparent 50%),
                        linear-gradient(160deg, var(--bg-1), var(--bg-2));
            animation: bgShift 14s ease-in-out infinite alternate;
        }

        @keyframes bgShift {
            from { background-position: 0 0, 0 0, 0 0, 0 0; }
            to   { background-position: 10% -5%, -10% 8%, 0% -6%, 0 0; }
        }

        #app-container {
            width: min(1200px, 96vw);
            background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.05));
            backdrop-filter: blur(var(--blur));
            -webkit-backdrop-filter: blur(var(--blur));
            padding: 28px;
            border-radius: var(--radius);
            border: 1px solid var(--border);
            box-shadow: var(--shadow), 0 0 0 1px rgba(255,255,255,.04) inset;
            position: relative;
            overflow: hidden;
            transform: translateZ(0);
            animation: fadeIn 400ms ease-out both;
        }

        #app-container::before {
            content: "";
            position: absolute;
            inset: -2px;
            background: radial-gradient(600px 200px at 20% -10%, rgba(124,58,237,.18) 0%, transparent 60%),
                        radial-gradient(400px 160px at 90% 10%, rgba(6,182,212,.18) 0%, transparent 60%);
            filter: blur(30px);
            z-index: 0;
        }

        h1 {
            margin: 0 0 18px 0;
            font-weight: 700;
            letter-spacing: -0.02em;
            font-size: clamp(22px, 2.2vw, 30px);
            background: linear-gradient(90deg, #fff, #c7d2fe 30%, #a5b4fc 60%, #e9d5ff);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            position: relative;
            z-index: 1;
        }

        .controls {
            position: relative;
            z-index: 1;
            margin-bottom: 14px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 10px;
            align-items: center;
        }

        .controls input,
        .controls button {
            height: 40px;
            padding: 0 12px;
            border-radius: var(--radius-sm);
            border: 1px solid var(--border);
            outline: none;
            background: linear-gradient(180deg, var(--glass-strong), var(--glass));
            color: var(--text);
            box-shadow: var(--shadow);
            transition: transform var(--transition), box-shadow var(--transition), border-color var(--transition), background var(--transition);
        }

        .controls input::placeholder { color: var(--muted); }

        .controls input:focus {
            border-color: rgba(124,58,237,.6);
            box-shadow: 0 0 0 3px rgba(124,58,237,.18);
        }

        .controls button {
            cursor: pointer;
            background: linear-gradient(180deg, rgba(124,58,237,.28), rgba(124,58,237,.16));
            border: 1px solid rgba(124,58,237,.35);
        }
        .controls button:hover { transform: translateY(-1px); box-shadow: 0 8px 24px rgba(124,58,237,.22); }
        .controls button:active { transform: translateY(0); }
        .controls button.active {
            background: linear-gradient(180deg, rgba(34,197,94,.36), rgba(34,197,94,.2));
            border-color: rgba(34,197,94,.45);
            color: #ecfdf5;
            box-shadow: 0 8px 24px rgba(34,197,94,.24), inset 0 1px 0 rgba(255,255,255,.12);
        }

        .color-picker {
            width: 40px;
            height: 40px;
            padding: 0;
            border: 1px solid var(--border);
            border-radius: 50%;
            overflow: hidden;
            cursor: pointer;
            background: var(--glass);
        }

        /* Range slider */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            border-radius: 999px;
            background: linear-gradient(90deg, rgba(124,58,237,.7), rgba(6,182,212,.7));
            outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px; height: 18px;
            border-radius: 50%;
            background: #fff;
            border: 2px solid rgba(124,58,237,.8);
            box-shadow: 0 2px 8px rgba(0,0,0,.35);
            cursor: pointer;
        }
        input[type="range"]::-moz-range-thumb {
            width: 18px; height: 18px; border-radius: 50%; background: #fff; border: 2px solid rgba(124,58,237,.8);
            box-shadow: 0 2px 8px rgba(0,0,0,.35); cursor: pointer;
        }

        #whiteboard {
            display: block;
            width: 800px; height: 600px;
            border-radius: var(--radius);
            border: 1px solid var(--border);
            background: linear-gradient(180deg, rgba(255,255,255,.9), rgba(255,255,255,.75));
            box-shadow: 0 20px 40px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.5);
            cursor: crosshair;
            image-rendering: -webkit-optimize-contrast;
        }

        .status-bar {
            margin-top: 14px;
            font-size: 0.9em;
            color: var(--muted);
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }
        .status-bar span {
            padding: 6px 10px;
            border-radius: var(--radius-xs);
            background: linear-gradient(180deg, var(--glass-strong), var(--glass));
            border: 1px solid var(--border);
            color: var(--text);
        }
        #webrtcStatus { color: var(--danger); }

        @keyframes fadeIn { from { opacity: 0; transform: translateY(6px); } to { opacity: 1; transform: translateY(0); } }
    </style>
</head>
<body>
    <div id="app-container">
        <h1>Collaborative Whiteboard</h1>

        <div class="controls">
            <input type="text" id="username" placeholder="Username" value="user_A">
            <button id="btnLogin">1. Login</button>
            <span id="authStatus">Not logged in.</span>
        </div>

        <div class="controls">
            <button id="btnCreate">2. Create Session</button>
            <input type="text" id="sessionIdInput" placeholder="Enter Session ID">
            <button id="btnJoin" disabled>3. Join Session</button>
        </div>

        <div class="controls">
            <button id="btnPen" class="active">Pen</button>
            <button id="btnEraser">Eraser</button>
            <input type="color" id="colorPicker" class="color-picker" value="#000000">
            <input type="range" id="sizeSlider" min="1" max="15" value="5">
            
            <button id="btnSave" disabled>4. Save Canvas</button>
            <button id="btnClear">Clear Local</button>
        </div>

        <canvas id="whiteboard" width="800" height="600"></canvas>
        <div class="status-bar">
            **Session:** <span id="sessionStatus">N/A</span> |
            **WebRTC Status:** <span id="webrtcStatus" style="color: red;">Disconnected</span> |
            **User:** <span id="currentUserName"></span>
        </div>
    </div>

    <script>
        // --- Global State ---
        const CANVAS_WIDTH = 800;
        const CANVAS_HEIGHT = 600;
        const canvas = document.getElementById('whiteboard');
        const ctx = canvas.getContext('2d');
        
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let drawingHistory = []; 
        let currentTool = 'pen'; // State for pen vs. eraser
        
        let peerConnection;
        let dataChannel;
        let ws; 
        
        // App State
        let currentToken = null;
        let currentSessionId = null;
        let currentUserName = '';

        // --- DEPLOYMENT CONFIGURATION ---
        // IMPORTANT: CHANGE 'localhost:8000' to your deployed server address (e.g., 'https://my-app.com')
        // index.html <script>
// The browser will automatically handle the 'https://' and 'wss://'
        const DEPLOYED_HOST = 'whiteboard-axcw.onrender.com'; 
// ... the rest of your code ... 
        const PROTOCOL = DEPLOYED_HOST.startsWith('localhost') ? 'http' : 'https';
        const WS_PROTOCOL = DEPLOYED_HOST.startsWith('localhost') ? 'ws' : 'wss';
        const API_BASE = `${PROTOCOL}://${DEPLOYED_HOST}/api`; 

        // --- UI Element References ---
        const authStatus = document.getElementById('authStatus');
        const sessionStatus = document.getElementById('sessionStatus');
        const webrtcStatus = document.getElementById('webrtcStatus');
        const currentUserNameEl = document.getElementById('currentUserName');
        const sessionIdInput = document.getElementById('sessionIdInput');
        
        // --- API & Auth Helpers ---
        function getAuthHeaders() {
            return {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${currentToken}`
            };
        }

        async function handleLogin() {
            const username = document.getElementById('username').value;
            if (!username) return alert("Please enter a username.");

            try {
                const response = await fetch(`${API_BASE}/login`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ username })
                });

                if (response.ok) {
                    const data = await response.json();
                    currentToken = data.access_token;
                    currentUserName = data.username;
                    authStatus.textContent = `Logged in as: ${currentUserName}`;
                    currentUserNameEl.textContent = currentUserName;
                    document.getElementById('btnJoin').disabled = false;
                    document.getElementById('btnCreate').disabled = false;
                } else {
                    alert("Login failed.");
                }
            } catch (error) {
                console.error('Login error:', error);
                alert("Login failed. Check server address/CORS or if the FastAPI server is running.");
            }
        }

        async function handleCreateSession() {
            if (!currentToken) return alert("Please log in first.");

            try {
                const response = await fetch(`${API_BASE}/sessions`, {
                    method: 'POST',
                    headers: getAuthHeaders()
                });

                if (response.ok) {
                    const session = await response.json();
                    currentSessionId = session.session_id;
                    sessionIdInput.value = currentSessionId;
                    handleJoinSession(true); // Auto-join and set as initiator
                } else {
                    alert("Failed to create session.");
                }
            } catch (error) {
                console.error('Create session error:', error);
            }
        }
        
        async function handleSaveCanvas() {
            if (!currentToken || !currentSessionId) {
                alert("Please join a session first.");
                return;
            }
            
            if (drawingHistory.length === 0) {
                alert("Nothing to save - canvas is empty.");
                return;
            }
            
            // Disable save button during save operation
            const saveBtn = document.getElementById('btnSave');
            saveBtn.disabled = true;
            sessionStatus.textContent = "Saving canvas...";
            
            try {
                console.log(`Saving ${drawingHistory.length} drawing commands to session ${currentSessionId}`);
                
                const response = await fetch(`${API_BASE}/sessions/${currentSessionId}/save`, {
                    method: 'POST',
                    headers: getAuthHeaders(),
                    body: JSON.stringify(drawingHistory) // Send the entire history array
                });

                if (response.status === 204) {
                    sessionStatus.textContent = `âœ“ Session ${currentSessionId} saved successfully!`;
                    console.log("Canvas saved successfully!");
                } else if (response.status === 404) {
                    const errorData = await response.json().catch(() => ({ detail: "Session not found" }));
                    alert(`Session not found: ${errorData.detail || "Please create or join a session first."}`);
                    sessionStatus.textContent = "Save failed: Session not found.";
                } else if (response.status === 401) {
                    alert("Authentication failed. Please log in again.");
                    sessionStatus.textContent = "Save failed: Authentication error.";
                } else if (response.status === 422) {
                    const errorData = await response.json().catch(() => ({ detail: "Validation error" }));
                    console.error("Validation error:", errorData);
                    alert(`Failed to save: ${errorData.detail || "Invalid data format."}`);
                    sessionStatus.textContent = "Save failed: Validation error.";
                } else {
                    const errorText = await response.text().catch(() => "Unknown error");
                    console.error("Save failed with status:", response.status, errorText);
                    alert(`Failed to save canvas state. Status: ${response.status}`);
                    sessionStatus.textContent = `Save failed (Status: ${response.status}).`;
                }
            } catch (error) {
                console.error('Save error:', error);
                alert(`Failed to save canvas: ${error.message || "Network error. Check console for details."}`);
                sessionStatus.textContent = "Save failed: Network error.";
            } finally {
                saveBtn.disabled = false;
            }
        }

        function clearCanvas() {
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            drawingHistory = []; // Clear local history
            sessionStatus.textContent = `Canvas cleared locally. (Must save to persist!)`;
        }

        // --- Canvas Drawing Logic ---
        function drawLine(x1, y1, x2, y2, color, size, tool) {
            ctx.beginPath();
            
            // Set globalCompositeOperation for eraser effect
            ctx.globalCompositeOperation = (tool === 'eraser') ? 'destination-out' : 'source-over'; 

            ctx.strokeStyle = color;
            ctx.lineWidth = size;
            ctx.lineCap = 'round';
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();

            // Reset composite operation to default
            ctx.globalCompositeOperation = 'source-over';
        }

        function handleRemoteDrawing(event) {
            try {
                const cmd = JSON.parse(event.data);
                if (cmd.x1 !== undefined) {
                    drawLine(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.color, cmd.size, cmd.tool);
                    drawingHistory.push(cmd); // Add remote command to history
                }
            } catch (e) {
                console.error("Failed to parse remote drawing data:", e);
            }
        }

        function setupCanvasDrawing() {
            canvas.addEventListener('mousedown', (e) => {
                // Only start drawing if a session is active
                if (!currentSessionId) return;
                isDrawing = true;
                [lastX, lastY] = [e.offsetX, e.offsetY];
            });

            canvas.addEventListener('mousemove', (e) => {
                if (!isDrawing || !currentSessionId) return;
                
                const color = document.getElementById('colorPicker').value;
                const size = parseInt(document.getElementById('sizeSlider').value);

                // For the eraser, use a white stroke color or the canvas background color
                const strokeColor = (currentTool === 'eraser') ? 'white' : color;
                
                // Draw locally
                drawLine(lastX, lastY, e.offsetX, e.offsetY, strokeColor, size, currentTool);
                
                const command = {
                    x1: lastX, y1: lastY, 
                    x2: e.offsetX, y2: e.offsetY, 
                    color: strokeColor, 
                    size: size,
                    tool: currentTool // Send the tool used!
                };

                // Add to history and send via WebRTC Data Channel
                drawingHistory.push(command); 
                if (dataChannel && dataChannel.readyState === 'open') {
                    dataChannel.send(JSON.stringify(command));
                }

                [lastX, lastY] = [e.offsetX, e.offsetY];
            });

            canvas.addEventListener('mouseup', () => isDrawing = false);
            canvas.addEventListener('mouseout', () => isDrawing = false);
        }

        function loadCanvasState(commands) {
            // Clear and reset state before loading
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            drawingHistory = []; 
            
            commands.forEach(cmd => {
                drawLine(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.color, cmd.size, cmd.tool);
                drawingHistory.push(cmd);
            });
            console.log(`Loaded ${commands.length} drawing commands.`);
        }

        // --- WebRTC Signaling and Peer Connection ---
        
        async function handleJoinSession(isInitiator = false) {
            currentSessionId = sessionIdInput.value.trim();
            if (!currentSessionId) return alert("Please enter a Session ID.");
            if (!currentToken) return alert("Please log in first.");

            sessionStatus.textContent = `Joining session: ${currentSessionId}...`;
            document.getElementById('btnSave').disabled = true;

            // 1. Load Initial Canvas State from API
            try {
                const response = await fetch(`${API_BASE}/sessions/${currentSessionId}`, { headers: getAuthHeaders() });
                if (!response.ok) throw new Error("Session load failed.");
                const sessionData = await response.json();
                loadCanvasState(sessionData.canvas_state); // Restore drawing
            } catch (error) {
                console.error("Error loading session:", error);
                sessionStatus.textContent = `Session ${currentSessionId} load failed. Check ID and server logs.`;
                return;
            }
            
            // 2. Setup WebSocket for Signaling
            ws = new WebSocket(`${WS_PROTOCOL}://${DEPLOYED_HOST}/ws/${currentSessionId}`);
            
            ws.onopen = () => {
                console.log("WebSocket connected. Starting WebRTC signaling...");
                setupPeerConnection(isInitiator);
            };
            
            // WebSocket Message Handler (Signaling Exchange)
            ws.onmessage = async (event) => {
                const signal = JSON.parse(event.data);

                if (signal.type === 'offer') {
                    await peerConnection.setRemoteDescription(new RTCSessionDescription(signal));
                    const answer = await peerConnection.createAnswer();
                    await peerConnection.setLocalDescription(answer);
                    ws.send(JSON.stringify(peerConnection.localDescription)); // Send Answer back
                } else if (signal.type === 'answer') {
                    await peerConnection.setRemoteDescription(new RTCSessionDescription(signal));
                } else if (signal.type === 'candidate') {
                    try {
                        await peerConnection.addIceCandidate(new RTCIceCandidate(signal.candidate));
                    } catch (e) {
                        console.error('Error adding received ICE candidate:', e);
                    }
                }
            };
            
            ws.onclose = () => console.log("WebSocket closed.");
            ws.onerror = (err) => console.error("WebSocket error:", err);
            
            sessionStatus.textContent = `Connected to session ${currentSessionId}. WebRTC connecting...`;
            document.getElementById('btnSave').disabled = false;
        }

        function setupPeerConnection(isInitiator) {
            peerConnection = new RTCPeerConnection({
                iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
            });

            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    ws.send(JSON.stringify({ type: 'candidate', candidate: event.candidate }));
                }
            };
            
            peerConnection.onconnectionstatechange = () => {
                webrtcStatus.textContent = peerConnection.connectionState;
                webrtcStatus.style.color = (peerConnection.connectionState === 'connected') ? 'green' : 'red';
            };
            
            if (isInitiator) {
                // Initiator creates the data channel
                dataChannel = peerConnection.createDataChannel('whiteboard-channel');
                dataChannel.onopen = (e) => console.log('Data Channel Open (Initiator)!');
                dataChannel.onmessage = handleRemoteDrawing;
                
                peerConnection.createOffer().then(offer => {
                    peerConnection.setLocalDescription(offer);
                    ws.send(JSON.stringify(offer)); // Send Offer
                });
            } else {
                // Receiver listens for the data channel
                peerConnection.ondatachannel = (event) => {
                    dataChannel = event.channel;
                    dataChannel.onopen = (e) => console.log('Data Channel Open (Receiver)!');
                    dataChannel.onmessage = handleRemoteDrawing;
                };
            }
        }
        
        // --- Initialization and Event Listeners ---
        document.getElementById('btnLogin').addEventListener('click', handleLogin);
        document.getElementById('btnCreate').addEventListener('click', handleCreateSession);
        document.getElementById('btnJoin').addEventListener('click', () => handleJoinSession(false)); 
        document.getElementById('btnSave').addEventListener('click', handleSaveCanvas);
        document.getElementById('btnClear').addEventListener('click', clearCanvas);

        // Tool Switching Logic
        function setTool(toolName) {
            currentTool = toolName;
            document.getElementById('btnPen').classList.remove('active');
            document.getElementById('btnEraser').classList.remove('active');
            document.getElementById(`btn${toolName.charAt(0).toUpperCase() + toolName.slice(1)}`).classList.add('active');
            console.log(`Tool switched to: ${toolName}`);
        }
        document.getElementById('btnPen').addEventListener('click', () => setTool('pen'));
        document.getElementById('btnEraser').addEventListener('click', () => setTool('eraser'));
        
        setupCanvasDrawing(); // Initialize canvas interaction
    </script>
</body>
</html>